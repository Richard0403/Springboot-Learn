# Spring Jpa关系映射

 关系映射中分为以下几种
 + 一对一
 + 一对多 and 多对一
 + 多对多 


### 一对一(@OneToOne)

一对一和一对多的实现方式有两种（个人倾向于第一种）
+ 外键的方式(一个实体通过外键关联到另一个实体的主键)
+ 通过关联表的方式，新建表保存两个实体一对一的关系

例如：People 和 Address 是一对一的关系
People
```
@Entity
public class People {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;//id
    @Column(name = "name", nullable = true, length = 20)
    private String name;//姓名
    @Column(name = "sex", nullable = true, length = 1)
    private String sex;//性别
    @Column(name = "birthday", nullable = true)
    private Timestamp birthday;//出生日期
    
    @OneToOne(cascade=CascadeType.ALL)//People是关系的维护端，当删除 people，会级联删除 address
    @JoinColumn(name = "address_id", referencedColumnName = "id")//people中的address_id字段参考address表中的id字段
    private Address address;//地址
}
```
 **@OneToOne(cascade=CascadeType.ALL)//People是关系的维护端，当删除 people，会级联删除 address
 @JoinColumn(name = "address_id", referencedColumnName = "id")//people中的address_id字段参考address表中的id字段
**

Address
```
@Entity
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = “id”, nullable = false)
    private Long id;//id
    @Column(name = “phone”, nullable = true, length = 11)
    private String phone;//手机
    @Column(name = “zipcode”, nullable = true, length = 6)
    private String zipcode;//邮政编码
    @Column(name = “address”, nullable = true, length = 100)
    private String address;//地址
    //如果不需要根据Address级联查询People，可以注释掉
//    @OneToOne(mappedBy = “address”, cascade = {CascadeType.MERGE, CascadeType.REFRESH}, optional = false)
//    private People people;
}
```
**mappedBy = “address”属性表明address是关系被维护端**

### 一对多(@OneToMany)
Author 和 Article 是一对多关系(双向)
JPA使用@OneToMany和@ManyToOne来标识一对多的双向关联。一端(Author)使用@OneToMany,多端(Article)使用@ManyToOne。
**在JPA规范中，一对多的双向关系由多端(Article)来维护。就是说多端(Article)为关系维护端，负责关系的增删改查。一端(Author)则为关系被维护端，不能维护关系**

Author
```
@Entity
public class Author {
    @Id // 主键
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 自增长策略
    private Long id; //id
    @NotEmpty(message = “姓名不能为空”)
    @Size(min=2, max=20)
    @Column(nullable = false, length = 20)
    private String name;//姓名
    @OneToMany(mappedBy = “author”,cascade=CascadeType.ALL,fetch=FetchType.LAZY)
    //级联保存、更新、删除、刷新;延迟加载。当删除用户，会级联删除该用户的所有文章
    //拥有mappedBy注解的实体类为关系被维护端
     //mappedBy=”author”中的author是Article中的author属性
    private List<Article> articleList;//文章列表
}
```
Article
```
@Entity
public class Article {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // 自增长策略
    @Column(name = “id”, nullable = false)
    private Long id;
    @NotEmpty(message = “标题不能为空”)
    @Size(min = 2, max = 50)
    @Column(nullable = false, length = 50) // 映射为字段，值不能为空
    private String title;
    @Lob  // 大对象，映射 MySQL 的 Long Text 类型
    @Basic(fetch = FetchType.LAZY) // 懒加载
    @NotEmpty(message = “内容不能为空”)
    @Size(min = 2)
    @Column(nullable = false) // 映射为字段，值不能为空
    private String content;//文章全文内容
    @ManyToOne(cascade={CascadeType.MERGE,CascadeType.REFRESH},optional=false)//可选属性optional=false,表示author不能为空。删除文章，不影响用户
    @JoinColumn(name=“author_id”)//设置在article表中的关联字段(外键)
    private Author author;//所属作者
}
```

### 多对多(@ManyToMany)
User和Authority(权限)是多对多的关系。一个用户可以有多个权限，一个权限也可以被很多用户拥有。

多对多的关系，由一个关联表来维护




